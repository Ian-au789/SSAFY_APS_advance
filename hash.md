# 해시

: 데이터를 고정된 크기의 값으로 변환하는 과정, 변환된 해시값은 원본 데이터를 고유하게 식별하거나 데이터를 빠르게 검색하는 데 사용

1. 빠른 데이터 검색, 삽입, 삭제 (시간 복잡도 O(1))

2. 데이터 무결성 검증 : 작은 변화에도 해시값이 크게 달라짐 -> 변조 여부 확인

3. 암호화 : 원본 대신 해시값 저장

4. 중복 제거: 동일한 데이터는 같은 해시값 가짐

5. 해시 충돌 : 서로 다른 입력값이 동일한 해시값을 생성하는 게 가능 -> 성능 저하의 원인

6. 메모리 사용량 : 해시 테이블은 배열보다 더 많은 메모리를 차지하며, 충돌 해결을 위한 추가 공간이 필요

7. 순서 보존 불가 : 해시 함수는 입력 데이터의 순서를 보존하지 않음

해시 테이블 : 해시 값을 인덱스로 사용하여 데이터를 저장하고 검색하는 자료구조


## 해시 함수 
: 입력값을 고정된 크기의 해시 값으로 변환하는 함수

### Division Hash Function
: 나머지 연산 해시 함수 [ h(k) = k mod m ]

- 가장 기본적인 형태
- key를 해시 테이블의 크기로 나눈 **나머지**를 hash 값으로 사용
- 구현 간단하고 계산 속도가 빠름
- 정수 키에 대해 효과적으로 작동
- 테이블 크기 선택에 민감
- 문자열이나 복잡한 키는 추가적인 처리 필요
- MAD (Multiply - Add - Divide) 등 사용하여 성능을 개선시킬 수 있음

### Multiplication Hash Function
:  곱셈 연산 해시 함수 [ h(k) = m(kA mod 1) ]

- 나머지 연산 해시 함수보다 더 균일한 분포 제공
- key를 0과 1 사이 실수로 변환해서 해시 테이블의 크기와 **곱하여** hash 값 사용
- 해시 테이블 크기에 비교적 덜 민감
- 구현이 더 복잡하고 부동 소수점 연산의 정밀도 문제 가능
- A값의 선택이 매우 중요

### Folding Hash Function
: 폴딩 해시 함수

- key를 여러 부분으로 나누고 이 부분들을 **조합**하여 hash 값 사용 (나눈 부분들을 더해서 해시 테이블 크기로 나눈 나머지)
- 주로 긴 문자열에 사용
- 짧은 키에 대해서는 오버헤드 가능
- 폴딩 크기 선택이 매우 중요
- 가중치 부여, 덧셈 대신 다른 방법 (xor, shift 등 비트 연산) 사용해 성능 개선 가능

### Polynomial Hash Function
: 다항식 해시 함수 [ h(s) = (s[0] * p^0 + s[1] * p^1 + ... + s[n-1] * p^(n-1)) mod m ]

- 문자열을 다항식으로 표현해서 hash 계산
- 문자열 처리에 유용, 패턴 매칭 알고리즘 (라빈-카프)에 유용
- 문자열 순서가 해시 값에 영향
- 긴 문자열은 오버 플로우 가능성 존재

### Secure Hash Algorithm 256-bit

: SHA - 256

- 임의의 길이의 입력 데이터를 고정된 크기의 256비트(32바이트) 해시 값으로 변환하는 함수
- 현대적이고 널리 사용되는 암호학적 해시 함수
- 입력 크기에 관계없이 항상 256비트 해시 값을 생성함
- 해시 값에서 원본 메세지를 복원하는 것이 실질적 불가능
- 입력의 작은 변화가 출력의 큰 변화를 야기함 (눈사태 효과)
- 같은 해시 값을 가진 두 개의 다른 입력을 찾기가 매우 어려움 (저항성)


## 해시 충돌
: 두 개 이상의 서로 다른 key가 동일한 hash 값을 생성하는 상황 (동일한 버킷에 저장되어야 하는 경우)

- 해시 값의 범위가 제한적이기 때문에 서로 다른 입력 데이터가 동일한 해시 값을 가질 가능성이 존재

- 해시 함수가 입력 데이터를 균등하게 분포시키지 못하면 충돌이 빈번하게 발생

- 무한한 입력을 유한한 출력(한정된 해시 테이블)로 매핑하는 과정에서 발생

- 성능 저하, 보안 위험, 데이터 무결성 침해

## 해시 충돌 해결 방법

1. 체이닝 : 충돌이 발생하면 해당 버킷의 연결리스트에 새 항목 추가, 추가 메모리 필요 및 최악의 경우 검색 시간 O(n)

2. 선형 탐사 : 충돌이 발생하면 순차적으로 다음 버킷을 검사하여 빈 슬롯을 찾는 방식, 로드 팩터(테이블에 저장된 항목 수 / 테이블 크기)가 특정 임계값을 초과하면 테이블 크기를 늘리고 모든 항목 재삽입

3. 제곱 탐사 : 충돌이 발생하면 원래 해시 값에서 제곱수만큼 떨어진 위치를 순차적으로 탐색, 이차 클러스터링 문제 발생 가능

4. 이중 해싱: 충돌 발생 시 또 다른 해시 함수로 탐사 간격 계산 후 빈 버킷에 삽입, 추가 연산 필요